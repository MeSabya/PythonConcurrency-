# Condition variable

The two important methods of a condition variable are:

âœ” wait() - invoked to make a thread sleep and give up resources

âœ” notify() - invoked by a thread when a condition becomes true and the invoking threads want to inform the waiting thread or threads to proceed

ðŸ‘‰ A condition variable is always associated with a lock. The lock can be either reentrant or a plain vanilla lock. The associated lock must be acquired before a thread can invoke wait()or notify() on the condition variable.

## Idiomatic use of wait()
```python
acquire lock
while(condition_to_test is not satisfied):
    wait

# condition is now true, perform necessary tasks

release lock
```

### Spurious Wakeups
>A peculiarity of condition variables is the possibility of spurious wakeups. It means that a thread might wakeup as if it has been signaled even though nobody called notify() on the condition variable in question. This is specifically allowed by the POSIX standard because it allows more efficient implementations of condition variables under some circumstances. Such wakeups are called spurious wakeups.

A thread that has been woken up does not imply that the conditions for it to move forward hold. The thread must test the conditions again for validity before moving forward. 
In conclusion, we must always check for conditions in a loop and wait() inside it ðŸ‘† python code above.

## Idiomatic use of notify
```python
acquire lock
set condition_to_test to true/satisfied
notify
release lock
```

## Quizes
#### Consider an abridged version of the code we discussed in this lesson. The child_task method exits without releasing the lock. What would be the outcome of running the program? The changed program is shown below:

```python
flag = False

lock = Lock()
cond_var = Condition(lock)


def child_task():
    global flag
    name = current_thread().getName()

    cond_var.acquire()
    while not flag:
        cond_var.wait()
        print("\n{0} woken up \n".format(name))

    print("\n{0} exiting\n".format(name))


if __name__ == "__main__":
    thread1 = Thread(target=child_task, name="thread1")
    thread1.start()
    
    # give the child task to wait on the condition variable
    time.sleep(1)

    cond_var.acquire()
    flag = True
    cond_var.notify_all()
    cond_var.release()

    thread1.join()
    print("main thread exits")
```

##### Answer is :
This is an interesting case, the single waiting thread exits without releasing the lock but since no other thread including the main thread attempts to acquire the lock the program sucessfully completes with the lock in locked state




