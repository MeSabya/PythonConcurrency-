major aspects of Future in Python, using ThreadPoolExecutor:

  - Submitting tasks
  - Getting results with .result()
  - Handling exceptions
  - Checking .done()
  - Using add_done_callback
  - Using as_completed

## Example: Multi-Task Processing with Futures

```python
from concurrent.futures import ThreadPoolExecutor, as_completed
import time
import random

def task(name, fail=False):
    """
    Simulate a task:
    - Sleeps 0.5â€“2 seconds
    - Optionally raises an exception
    """
    sleep_time = random.uniform(0.5, 2.0)
    print(f"[{name}] Starting, will take {sleep_time:.2f}s")
    time.sleep(sleep_time)
    if fail and random.choice([True, False]):
        raise ValueError(f"Task {name} failed randomly!")
    print(f"[{name}] Finished")
    return f"{name} result"

def done_callback(fut):
    """Called when future is done"""
    try:
        result = fut.result()
        print(f"[Callback] Result: {result}")
    except Exception as e:
        print(f"[Callback] Task raised exception: {e}")

def main():
    tasks = [
        ("Task1", False),
        ("Task2", True),
        ("Task3", False),
        ("Task4", True)
    ]

    # Create ThreadPoolExecutor
    with ThreadPoolExecutor(max_workers=3) as executor:
        # Submit tasks and attach callback
        futures = []
        for name, fail in tasks:
            fut = executor.submit(task, name, fail)
            fut.add_done_callback(done_callback)
            futures.append(fut)

        print("\nPolling futures for completion...")
        while futures:
            for fut in futures:
                if fut.done():
                    try:
                        result = fut.result()
                        print(f"[Main Loop] Got result: {result}")
                    except Exception as e:
                        print(f"[Main Loop] Got exception: {e}")
                    futures.remove(fut)
            time.sleep(0.1)

        print("\nUsing as_completed to process remaining futures (should be empty now):")
        for fut in as_completed(futures):
            try:
                print("Result:", fut.result())
            except Exception as e:
                print("Exception:", e)

if __name__ == "__main__":
    main()
```


