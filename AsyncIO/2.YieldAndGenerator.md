# Yield
- When you are on the road you may come across "yield to pedestrians" sign boards which require you to stop and give way to pedestrians crossing the road. 
- Python's use of the word yield can both produce values and also give way.

```python
def keep_learning_asynchronous():
    yield "Educative"


if __name__ == "__main__":
    str = keep_learning_asynchronous()
    str = next(gen)
    print(str)
```

What is happening ☝️?

❗So instead of being returned the string, we are returned a generator object as the print statement shows. In fact our method **keep_learning_asynchronous() is now a generator function**. Generator functions are called as generators because they generate values.
**Since we are passing generator objects into next() we can conclude that generators are iterators.**
We can use for loops with a generator also:

```python
gen = keep_learning_asynchronous()
    for item in gen:
        print(item)
```

### Multiple yield statements 
```python
def keep_learning_asynchronous():
    yield "Educative"
    yield "is great!"


if __name__ == "__main__":
    gen = keep_learning_asynchronous()
    for item in gen:
        print(item)
```

### Return and Yield together , how to capture StopIteration exception 
👉 If we attempt to invoke next() on a generator object that had already produced (yielded) all its values, we'll be thrown a **StopIteration** exception.

```python 
def keep_learning_asynchronous():
    yield "Educative"
    return "is great"


if __name__ == "__main__":
    gen = keep_learning_asynchronous()

    first_string = next(gen)
    print(first_string)

    try:
        next(gen)
    except StopIteration as e:
        second_string = e.value
        print(second_string) 
```
👉 Also **Anytime you return from a generator function, it'll be equivalent of raising the StopIteration exception.**

### Suspended State 
>Yield allows a function to return a value and let the state of the function suspend till next() is invoked on the associated generator object.

# Generators
✔ Using a yield expression in a function’s body causes that function to be a generator. 

✔ These functions return an object which supports the iteration protocol methods. The generator object created, automatically receives a __next()__ method. 

✔ Generator functions allow us to procrastinate computing expensive values. We only compute the next value when required. This makes generators memory and compute efficient. They refrain from saving long sequences in memory or doing all expensive computations upfront.

✔ Generators when suspended retain the code location, which is the last yield statement executed, and their entire local scope. This allows them to resume execution from where they left off.

✔ Generator objects are nothing more than iterators.

### States of a generator
A generator goes through the following states:

1. **GEN_CREATED** when a generator object has been returned for the first time from a generator function and iteration hasn't started.

2. **GEN_RUNNING** when next has been invoked on the generator object and is being executed by the python interpreter.

3. **GEN_SUSPENDED** when a generator is suspended at a yield

4. **GEN_CLOSED** when a generator has completed execution or has been closed. We'll learn about closing generators later.

### Methods of Generator Objects
A generator object exposes different methods that can be invoked to manipulate the generator. These are:

    ✔throw()

    ✔send()

    ✔close()

#### Close() Method

- The intent of the close() method is to give the generator a chance to clean-up before it exits.
- A generator function can catch the GeneratorException and perform clean-up actions.

What happens in the code below 👇

```python
def get_item():
    try:
        yield 5

    except GeneratorExit:
        print("GeneratorExit exception raised")


if __name__ == "__main__":
    gen = get_item()

    print(next(gen))
    print("Main exiting")
```

>Notice the exception raised statement appears in the output after the main exiting statement. The Python interpreter garbage collects the gen variable, which is a generator, and invokes close() on it, which is why the exception raised statement is printed after the main exiting statement.

👉Contrast the above output with the one below, where we explicitly invoke the close() method on the gen object

```python 
def get_item():
    try:
        yield 5

    except GeneratorExit:
        print("GeneratorExit exception raised")


if __name__ == "__main__":
    gen = get_item()

    print(next(gen))
    gen.close()
    print("main exiting")
```
    

